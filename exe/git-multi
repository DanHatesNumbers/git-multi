#!/usr/bin/env ruby

lib = File.expand_path('../../lib', __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
require 'git/multi'

if (command = ARGV.shift).start_with? '++'
  multi_repo = command[2..-1]
  if Git::Multi.valid?(multi_repo)
    command = nil
  else
    abort \
      "Unknown multi repo: #{multi_repo}\n\n" \
      '(use --check to list all known multi repos)'
  end
end

case (command ||= ARGV.shift)
when /\A--/
  case command
  when '--help'    then Git::Multi::Commands.help
  when '--html'    then Git::Multi::Commands.html
  when '--check'   then Git::Multi::Commands.check
  when '--version' then Git::Multi::Commands.version
  when '--refresh' then Git::Multi::Commands.refresh
  when '--json'    then Git::Multi::Commands.json(multi_repo)
  when '--count'   then Git::Multi::Commands.count
  when '--list'    then Git::Multi::Commands.list(multi_repo)
  when '--archived'then Git::Multi::Commands.archived(multi_repo)
  when '--forked'  then Git::Multi::Commands.forked(multi_repo)
  when '--private' then Git::Multi::Commands.private(multi_repo)
  when '--paths'   then Git::Multi::Commands.paths(multi_repo)
  when '--spurious'then Git::Multi::Commands.spurious
  when '--missing' then Git::Multi::Commands.missing(multi_repo)
  when '--stale'   then Git::Multi::Commands.stale
  when '--excess'  then Git::Multi::Commands.excess
  when '--clone'   then Git::Multi::Commands.clone(multi_repo)
  when '--query'   then Git::Multi::Commands.query(ARGV, multi_repo)
  when '--find'    then Git::Multi::Commands.find(ARGV, multi_repo)
  when '--eval'    then Git::Multi::Commands.eval(ARGV, multi_repo)
  when '--raw'     then Git::Multi::Commands.raw(ARGV, multi_repo)
  else
    abort \
      "Unknown 'git multi' command: #{command}\n\n" \
      '(use --help/-h to list all available commands)'
  end
when nil, '', '-h'
  Git::Multi::Commands.help
else
  # Git::Multi::Commands.report
  Git::Multi::Commands.exec(command, ARGV, multi_repo)
end

# That's all Folks!
